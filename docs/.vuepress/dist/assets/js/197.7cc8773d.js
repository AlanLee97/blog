(window.webpackJsonp=window.webpackJsonp||[]).push([[197],{431:function(a,e,E){"use strict";E.r(e);var t=E(0),v=Object(t.a)({},(function(){var a=this,e=a.$createElement,E=a._self._c||e;return E("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[E("h1",{attrs:{id:"_41-突破难点：如何看-lambda-源码"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#_41-突破难点：如何看-lambda-源码"}},[a._v("#")]),a._v(" 41 突破难点：如何看 Lambda 源码")]),a._v(" "),E("p",[E("img",{attrs:{src:"E:/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/OneDrive/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/note_images/5ddb3518000154d406400359.jpg",alt:"img"}})]),a._v(" "),E("p",[E("img",{attrs:{src:"E:/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/OneDrive/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/note_images/bg-l-1580743001463.png",alt:"img"}}),E("img",{attrs:{src:"E:/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/OneDrive/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/note_images/bg-r-1580743001472.png",alt:"img"}})]),a._v(" "),E("p",[a._v("耐心和恒心总会得到报酬的。")]),a._v(" "),E("p",[a._v("——爱因斯坦")]),a._v(" "),E("h2",{attrs:{id:"引导语"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#引导语"}},[a._v("#")]),a._v(" 引导语")]),a._v(" "),E("p",[a._v("大家都知道 Java8 中新增了 Lambda 表达式，使用 Lambda 表达式可以对代码进行大量的优化，用几行代码就可以做很多事情，本章以 Lambda 为例，第一小节说明一下其底层的执行原理，第二小节说明一下 Lambda 流在工作中常用的姿势。")]),a._v(" "),E("h2",{attrs:{id:"_1-demo"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#_1-demo"}},[a._v("#")]),a._v(" 1 Demo")]),a._v(" "),E("p",[a._v("首先我们来看一个 Lambda 表达式的 Demo，如下图：\n"),E("img",{attrs:{src:"E:/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/OneDrive/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/note_images/5dd5fe830001211007440492.png",alt:"图片描述"}})]),a._v(" "),E("p",[a._v("代码比较简单，就是新起一个线程打印一句话，但对于图中 () -> System.out.println ( “ lambda is run “ ) 这种代码，估计很多同学都感觉到很困惑，Java 是怎么识别这种代码的？")]),a._v(" "),E("p",[a._v("如果我们修改成匿名内部类的写法，就很清楚，大家都能看懂，如下图：\n"),E("img",{attrs:{src:"E:/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/OneDrive/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/note_images/5dd5fe980001358906980558.png",alt:"图片描述"}})]),a._v(" "),E("p",[a._v("那是不是说 () -> System.out.println ( “ lambda is run “ ) 这种形式的代码，其实就是建立了内部类呢？其实这就是最简单 Lambda 表达式，我们是无法通过 IDEA 看到源码和其底层结构的，下面我们就来介绍几种可看到其底层实现的方式。")]),a._v(" "),E("h2",{attrs:{id:"_2-异常判断法"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#_2-异常判断法"}},[a._v("#")]),a._v(" 2 异常判断法")]),a._v(" "),E("p",[a._v("我们可以在代码执行中主动抛出异常，打印出堆栈，堆栈会说明其运行轨迹，一般这种方法简单高效，基本上可以看到很多情况下的隐藏代码，我们来试一下，如下图：\n"),E("img",{attrs:{src:"E:/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/OneDrive/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/note_images/5dd5fea9000187c107670699.png",alt:"图片描述"}})]),a._v(" "),E("p",[a._v("从异常的堆栈中，我们可以看到 JVM 自动给当前类建立了内部类（错误堆栈中出现多次的 $ 表示有内部类），内部类的代码在执行过程中，抛出了异常，但这里显示的代码是 Unknown Source，所以我们也无法 debug 进去，一般情况下，异常都能暴露出代码执行的路径，我们可以打好断点后再次运行，但对于 Lambda 表达式而言，通过异常判断法我们只清楚有内部类，但无法看到内部类中的源码。")]),a._v(" "),E("h2",{attrs:{id:"_3-javap-命令法"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#_3-javap-命令法"}},[a._v("#")]),a._v(" 3 javap 命令法")]),a._v(" "),E("p",[a._v("javap 是 Java 自带的可以查看 class 字节码文件的工具，安装过 Java 基础环境的电脑都可以直接执行 javap 命令，如下图：\n"),E("img",{attrs:{src:"E:/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/OneDrive/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/note_images/5dd5fec0000181d909200570.png",alt:"图片描述"}})]),a._v(" "),E("p",[a._v("命令选项中，我们主要是用-v -verbose 这个命令，可以完整输出字节码文件的内容。")]),a._v(" "),E("p",[a._v("接下来我们使用 javap 命令查看下 Lambda.class 文件，在讲解的过程中，我们会带上一些关于 class 文件的知识。")]),a._v(" "),E("p",[a._v("我们在命令窗口中找到 Lambda.class 所在的位置，执行命令：javap -verbose Lambda.class，然后你会看到一长串的东西，这些叫做汇编指令，接下来我们来一一讲解下（ 所有的参考资料来自 "),E("a",{attrs:{href:"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java 虚拟机规范"),E("OutboundLink")],1),a._v("，不再一一引用说明）：")]),a._v(" "),E("p",[a._v("汇编指令中我们很容易找到 Constant pool 打头的一长串类型，我们叫做常量池，官方英文叫做 Run-Time Constant Pool，我们简单理解成一个装满常量的 table ，table 中包含编译时明确的数字和文字，类、方法和字段的类型信息等等。table 中的每个元素叫做 cp"),E("em",[a._v("info，cp")]),a._v("info 由唯一标识 ( tag ) + 名称组成，目前 tag 的类型一共有：\n"),E("img",{attrs:{src:"E:/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/OneDrive/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/note_images/5dd5fedc00012eb605020734.png",alt:"图片描述"}})]),a._v(" "),E("p",[a._v("贴出我们解析出来的部分图：\n"),E("img",{attrs:{src:"E:/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/OneDrive/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/note_images/5dd5fee90001bf8118760941.png",alt:"图片描述"}})]),a._v(" "),E("ol",[E("li",[a._v("图中 Constant pool 字样代表当前信息是常量池；")]),a._v(" "),E("li",[a._v("每行都是一个 "),E("code",[a._v("cp_info")]),a._v(" ，第一列的 #1 代表是在常量池下标为 1 的位置 ；")]),a._v(" "),E("li",[a._v("每行的第二列，是 "),E("code",[a._v("cp_info")]),a._v(" 的唯一标识 ( tag ) ，比如 Methodref 对应着上表中的 CONSTANT_Methodref（上上图中表格中 value 对应 10 的 tag），代表当前行是表示方法的描述信息的，比如说方法的名称，入参类型，出参数类型等，具体的含义在 Java 虚拟机规范中都可以查询到，Methodref 的截图如下：\n"),E("img",{attrs:{src:"E:/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/OneDrive/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/note_images/5dd5ff070001ff6219441450.png",alt:"图片描述"}})]),a._v(" "),E("li",[a._v("每行的第三列，如果是具体的值的话，直接显示具体的值，如果是复杂的值的话，会显示 "),E("code",[a._v("cp_info")]),a._v(" 的引用，比如说图中标红 2 处，引用两个 13 和 14 位置的 "),E("code",[a._v("cp_info")]),a._v("，13 表示方法名字是 init，14 表示方法无返回值，结合起来表示方法的名称和返回类型，就是一个无参构造器；")]),a._v(" "),E("li",[a._v("每行的第四列，就是具体的值了。")])]),a._v(" "),E("p",[a._v("对于比较重要的 cp_info 类型我们说明下其含义：")]),a._v(" "),E("ol",[E("li",[a._v("InvokeDynamic 表示动态的调用方法，后面我们会详细说明；")]),a._v(" "),E("li",[a._v("Fieldref 表示字段的描述信息，如字段的名称、类型；")]),a._v(" "),E("li",[a._v("NameAndType 是对字段和方法类型的描述；")]),a._v(" "),E("li",[a._v("MethodHandle 方法句柄，动态调用方法的统称，在编译时我们不知道具体是那个方法，但运行时肯定会知道调用的是那个方法；")]),a._v(" "),E("li",[a._v("MethodType 动态方法类型，只有在动态运行时才会知道其方法类型是什么。")])]),a._v(" "),E("p",[a._v("我们从上上图中标红的 3 处，发现 Ljava/lang/invoke/MethodHandles$Lookup，java/lang/invoke/LambdaMetafactory.metafactory 类似这样的代码，MethodHandles 和 LambdaMetafactory 都是 java.lang.invoke 包下面的重要方法，invoke 包主要实现了动态语言的功能，我们知道 java 语言属于静态编译语言，在编译的时候，类、方法、字段等等的类型都已经确定了，而 invoke 实现的是一种动态语言，也就是说编译的时候并不知道类、方法、字段是什么类型，只有到运行的时候才知道。")]),a._v(" "),E("p",[a._v("比如这行代码：Runnable runnable = () -> System.out.println(“lambda is run”); 在编译器编译的时候 () 这个括号编译器并不知道是干什么的，只有在运行的时候，才会知道原来这代表着的是 Runnable.run() 方法。invoke 包里面很多类，都是为了代表这些 () 的，我们称作为方法句柄（ MethodHandler ），在编译的时候，编译器只知道这里是个方法句柄，并不知道实际上执行什么方法，只有在执行的时候才知道，那么问题来了，JVM 执行的时候，是如何知道 () 这个方法句柄，实际上是执行 Runnable.run() 方法的呢？")]),a._v(" "),E("p",[a._v("首先我们看下 simple 方法的汇编指令：\n"),E("img",{attrs:{src:"E:/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/OneDrive/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/note_images/5dd5ff170001644407650528.png",alt:"图片描述"}})]),a._v(" "),E("p",[a._v("从上图中就可以看出 simple 方法中的 () -> System.out.println(“lambda is run”) 代码中的 ()，实际上就是 Runnable.run 方法。")]),a._v(" "),E("p",[a._v("我们追溯到 # 2 常量池，也就是上上图中标红 1 处，InvokeDynamic 表示这里是个动态调用，调用的是两个常量池的 cp_info，位置是 #0:#37 ，我们往下找 #37 代表着是 // run:()Ljava/lang/Runnable，这里表明了在 JVM 真正执行的时候，需要动态调用 Runnable.run() 方法，从汇编指令上我们可以看出 () 实际上就是 Runnable.run()，下面我们 debug 来证明一下。")]),a._v(" "),E("p",[a._v("我们在上上图中 3 处发现了 LambdaMetafactory.metafactory 的字样，通过查询官方文档，得知该方法正是执行时， 链接到真正代码的关键，于是我们在 metafactory 方法中打个断点 debug 一下，如下图：\n"),E("img",{attrs:{src:"E:/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/OneDrive/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/note_images/5dd5ff2d0001ae9417980859.png",alt:"图片描述"}})]),a._v(" "),E("p",[a._v("metafactory 方法入参 caller 代表实际发生动态调用的位置，invokedName 表示调用方法名称，invokedType 表示调用的多个入参和出参，samMethodType 表示具体的实现者的参数，implMethod 表示实际上的实现者，instantiatedMethodType 等同于 implMethod。")]),a._v(" "),E("p",[a._v("以上内容总结一下：")]),a._v(" "),E("p",[a._v("1：从汇编指令的 simple 方法中，我们可以看到会执行 Runnable.run 方法；")]),a._v(" "),E("p",[a._v("2：在实际的运行时，JVM 碰到 simple 方法的 invokedynamic 指令，会动态调用 LambdaMetafactory.metafactory 方法，执行具体的 Runnable.run 方法。")]),a._v(" "),E("p",[a._v("所以可以把 Lambda 表达值的具体执行归功于 invokedynamic JVM 指令，正是因为这个指令，才可以做到虽然编译时不知道要干啥，但动态运行时却能找到具体要执行的代码。")]),a._v(" "),E("p",[a._v("接着我们看一下在汇编指令输出的最后，我们发现了异常判断法中发现的内部类，如下图：\n"),E("img",{attrs:{src:"E:/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/OneDrive/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/note_images/5dd5ff450001783a13491048.png",alt:"图片描述"}})]),a._v(" "),E("p",[a._v("上图中箭头很多，一层一层的表达清楚了当前内部类的所有信息。")]),a._v(" "),E("h2",{attrs:{id:"_4-总结"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#_4-总结"}},[a._v("#")]),a._v(" 4 总结")]),a._v(" "),E("p",[a._v("我们总结一下，Lambda 表达式执行主要是依靠 invokedynamic 的 JVM 指令来实现，咱们演示的类的全路径为：demo.eight.Lambda 感兴趣的同学可以自己尝试一下。")])])}),[],!1,null,null,null);e.default=v.exports}}]);