(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{377:function(t,v,a){"use strict";a.r(v);var _=a(0),e=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"第16次题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第16次题"}},[t._v("#")]),t._v(" 第16次题")]),t._v(" "),a("p",[t._v("1.下列类在多重catch中同时出现时，哪一个异常类应最后一个列出（）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("A、ArithmeticException\nB、NumberFormatException\nC、Exception\nD、ArrayIndexOutOfBoundException\n")])])]),a("p",[a("strong",[t._v("答案")])]),t._v(" "),a("p",[t._v("C、Exception")]),t._v(" "),a("p",[a("strong",[t._v("解释")])]),t._v(" "),a("p",[t._v("这是多重catch块的顺序问题，由于异常处理系统就近寻找匹配异常处理程序，应先子类后父类。")]),t._v(" "),a("p",[t._v("2.关于依赖注入，下列选项中说法错误的是（）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("A、依赖注入能够独立开发各组件，然后根据组件间关系进行组装\nB、依赖注入使组件之间相互依赖，相互制约\nC、依赖注入提供使用接口编程\nD、依赖注入指对象在使用时动态注入\n")])])]),a("p",[a("strong",[t._v("答案")])]),t._v(" "),a("p",[t._v("B")]),t._v(" "),a("p",[a("strong",[t._v("解释")])]),t._v(" "),a("p",[t._v("依赖注入和控制反转是同一概念：")]),t._v(" "),a("p",[t._v("依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。依赖注入是从应用程序的角度在描述，可以把依赖注入描述完整点：应用程序依赖容器创建并注入它所需要的外部资源；而控制反转是从容器的角度在描述，描述完整点：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。")]),t._v(" "),a("p",[t._v("3.下面哪个不是标准Statement类？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Statement\nPreparedStatement\nCallableStatement\nBatchedStatement\n")])])]),a("p",[a("strong",[t._v("答案")])]),t._v(" "),a("p",[t._v("BatchedStatement")]),t._v(" "),a("p",[a("strong",[t._v("解释")])]),t._v(" "),a("p",[t._v("Statement是sql语句的载体")]),t._v(" "),a("p",[t._v("Statement是标准的Statement类，通过字符串对sql语句进行拼接，但是它存在sql注入的危险")]),t._v(" "),a("p",[t._v("PreparedStatement对sql语句进行了预编译，可以防止SQL注入")]),t._v(" "),a("p",[t._v("CallableStatement用来调用存储过程的")]),t._v(" "),a("p",[t._v("BatchedStatement用于批量操作数据库，BatchedStatement不是标准的Statement类")]),t._v(" "),a("p",[t._v("4.下列语句正确的是：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("形式参数可被字段修饰符修饰\n形式参数不可以是对象\n形式参数为方法被调用时真正被传递的参数\n形式参数可被视为local variable\n")])])]),a("p",[a("strong",[t._v("答案")])]),t._v(" "),a("p",[t._v("形式参数可被视为local variable")]),t._v(" "),a("p",[a("strong",[t._v("解释")])]),t._v(" "),a("p",[t._v("分类")]),t._v(" "),a("p",[t._v("Java语言提供了很多修饰符，大概分为两类：")]),t._v(" "),a("p",[t._v("\\1. 访问权限修饰符")]),t._v(" "),a("p",[t._v("\\2. 非访问权限修饰符")]),t._v(" "),a("p",[t._v("访问权限修饰符")]),t._v(" "),a("ol",[a("li",[t._v("public：共有访问。对所有的类都可见。")]),t._v(" "),a("li",[t._v("protected：保护型访问。对同一个包可见，对不同的包的子类可见。")]),t._v(" "),a("li",[t._v("default：默认访问权限。只对同一个包可见，注意对不同的包的子类不可见。")]),t._v(" "),a("li",[t._v("private：私有访问。只对同一个类可见，其余都不见。")])]),t._v(" "),a("p",[t._v("非访问权限修饰符")]),t._v(" "),a("ol",[a("li",[t._v("static 修饰符，用来创建类方法和类变量。")]),t._v(" "),a("li",[t._v("final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。")]),t._v(" "),a("li",[t._v("abstract 修饰符，用来创建抽象类和抽象方法。")]),t._v(" "),a("li",[t._v("synchronized 用于多线程的同步。")]),t._v(" "),a("li",[t._v("volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。")]),t._v(" "),a("li",[t._v("transient：序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。")])]),t._v(" "),a("p",[t._v("类")]),t._v(" "),a("p",[t._v("外部类修饰符")]),t._v(" "),a("ul",[a("li",[t._v("public（访问控制符），将一个类声明为公共类，它可以被任何对象访问，一个程序的主类必须是公共类。")]),t._v(" "),a("li",[t._v("default（访问控制符），类只对包内可见，包外不可见。")]),t._v(" "),a("li",[t._v("abstract（非访问控制符），将一个类声明为抽象类，抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充，抽象类可以包含抽象方法和非抽象方法。。")]),t._v(" "),a("li",[t._v("final（非访问控制符），将一个类生命为最终（即非继承类），表示它不能被其他类继承。")])]),t._v(" "),a("p",[t._v("注意：")]),t._v(" "),a("p",[t._v("1.protected 和 private 不能修饰外部类，是因为外部类放在包中，只有两种可能，包可见和包不可见。")]),t._v(" "),a("p",[t._v("\\2. final 和 abstract不能同时修饰外部类，因为该类要么能被继承要么不能被继承，二者只能选其一。")]),t._v(" "),a("p",[t._v("3.不能用static修饰类，因为类加载后才会加载静态成员变量。所以不能用static修饰类和接口，因为类还没加载，无法使用static关键字。")]),t._v(" "),a("p",[t._v("内部类修饰符")]),t._v(" "),a("p",[t._v("​    内部类与成员变量地位一直，所以可以public,protected、default和private，同时还可以用static修饰，表示嵌套内部类，不用实例化外部类，即可调用。")]),t._v(" "),a("p",[t._v("方法修饰符")]),t._v(" "),a("ol",[a("li",[t._v("public（公共控制符），包外包内都可以调用该方法。")]),t._v(" "),a("li",[t._v("protected（保护访问控制符）指定该方法可以被它的类和子类进行访问。具体细节可参考：http://blog.csdn.net/dawn_after_dark/article/details/74453915")]),t._v(" "),a("li",[t._v("default(默认权限），指定该方法只对同包可见，对不同包（含不同包的子类）不可见。")]),t._v(" "),a("li",[t._v("private（私有控制符）指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类），非常严格的控制。")]),t._v(" "),a("li",[t._v("final ,指定方法已完备，不能再进行继承扩充。")]),t._v(" "),a("li",[t._v("static，指定不需要实例化就可以激活的一个方法，即在内存中只有一份，通过类名即可调用。")]),t._v(" "),a("li",[t._v("synchronize，同步修饰符，在多个线程中，该修饰符用于在运行前，对它所属的方法加锁，以防止其他线程的访问，运行结束后解锁。")]),t._v(" "),a("li",[t._v("native，本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。")]),t._v(" "),a("li",[t._v("abstract ,抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾，例如：public abstract sample();。")])]),t._v(" "),a("p",[t._v("成员变量修饰符")]),t._v(" "),a("ul",[a("li",[t._v("public（公共访问控制符），指定该变量为公共的，它可以被任何对象的方法访问。")]),t._v(" "),a("li",[t._v("protected（保护访问控制符）指定该变量可以别被自己的类和子类访问。在子类中可以覆盖此变量。")]),t._v(" "),a("li",[t._v("default(默认权限），指定该变量只对同包可见，对不同包（含不同包的子类）不可见。")]),t._v(" "),a("li",[t._v("private（私有访问控制符）指定该变量只允许自己的类的方法访问，其他任何类（包括子类）中的方法均不能访问。")]),t._v(" "),a("li",[t._v("final，最终修饰符，指定此变量的值不能变。")]),t._v(" "),a("li",[t._v("static（静态修饰符）指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。")]),t._v(" "),a("li",[t._v("transient（过度修饰符）指定该变量是系统保留，暂无特别作用的临时性变量。不持久化。")]),t._v(" "),a("li",[t._v("volatile（易失修饰符）指定该变量可以同时被几个线程控制和修改，保证两个不同的线程总是看到某个成员变量的同一个值。")])]),t._v(" "),a("p",[t._v("final 和 static 经常一起使用来创建常量。")]),t._v(" "),a("p",[t._v("局部变量修饰符")]),t._v(" "),a("p",[t._v("only final is permitted。")]),t._v(" "),a("p",[t._v("为什么不能赋予权限修饰符？")]),t._v(" "),a("p",[t._v("因为局部变量的生命周期为一个方法的调用期间，所以没必要为其设置权限访问字段，既然你都能访问到这个方法，所以就没必要再为其方法内变量赋予访问权限，因为该变量在方法调用期间已经被加载进了虚拟机栈，换句话说就是肯定能被当前线程访问到，所以设置没意义。")]),t._v(" "),a("p",[t._v("为什么不能用static修饰")]),t._v(" "),a("p",[t._v("我们都知道静态变量在方法之前先加载的，所以如果在方法内设置静态变量，可想而知，方法都没加载，你能加载成功方法内的静态变量？")]),t._v(" "),a("p",[t._v("接口")]),t._v(" "),a("p",[t._v("接口修饰符")]),t._v(" "),a("p",[t._v("接口修饰符只能用public、default和abstract。")]),t._v(" "),a("p",[t._v("不能用final、static修饰。")]),t._v(" "),a("p",[t._v("接口默认修饰为abstract。")]),t._v(" "),a("p",[t._v("接口中方法修饰符")]),t._v(" "),a("p",[t._v("only public & abstract are permitted 。")]),t._v(" "),a("p",[t._v("意思只能用 public abstract修饰，当然如果你什么都不写，默认就是public abstract。")]),t._v(" "),a("p",[t._v("注意：在Java1.8之后，接口允许定义static 静态方法了！所以也可以用static来修饰！")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://uploadfiles.nowcoder.com/images/20171023/9430388_1508736012435_F21604BDD6B5A8912481FAC56612272B",alt:"img"}})]),t._v(" "),a("p",[t._v("5.下面有关java threadlocal说法正确的有？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("A、ThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递\nB、线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收\nC、在Thread类中有一个Map，用于存储每一个线程的变量的副本。\nD、对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式\n")])])]),a("p",[a("strong",[t._v("答案")])]),t._v(" "),a("p",[t._v("ABCD")]),t._v(" "),a("p",[a("strong",[t._v("解释")])]),t._v(" "),a("p",[t._v("ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。 可以总结为一句话：ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 举个例子，我出门需要先坐公交再做地铁，这里的坐公交和坐地铁就好比是同一个线程内的两个函数，我就是一个线程，我要完成这两个函数都需要同一个东西：公交卡（北京公交和地铁都使用公交卡），那么我为了不向这两个函数都传递公交卡这个变量（相当于不是一直带着公交卡上路），我可以这么做：将公交卡事先交给一个机构，当我需要刷卡的时候再向这个机构要公交卡（当然每次拿的都是同一张公交卡）。这样就能达到只要是我(同一个线程)需要公交卡，何时何地都能向这个机构要的目的。 有人要说了：你可以将公交卡设置为全局变量啊，这样不是也能何时何地都能取公交卡吗？但是如果有很多个人（很多个线程）呢？大家可不能都使用同一张公交卡吧(我们假设公交卡是实名认证的)，这样不就乱套了嘛。现在明白了吧？这就是ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。")])])}),[],!1,null,null,null);v.default=e.exports}}]);