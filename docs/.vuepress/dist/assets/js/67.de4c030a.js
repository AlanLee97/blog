(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{414:function(a,t,e){"use strict";e.r(t);var s=e(0),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"第2次题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第2次题"}},[a._v("#")]),a._v(" 第2次题")]),a._v(" "),e("p",[e("strong",[a._v("1.下列关于修饰符混用的说法，错误的是( )")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("abstract不能与final并列修饰同一个类\nabstract 类中不建议有private的成员\nabstract 方法必须在abstract类或接口中\nstatic方法中能直接处理非static的属性\n")])])]),e("p",[e("strong",[a._v("答案")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("static方法中能直接处理非static的属性\n")])])]),e("p",[e("strong",[a._v("解释")])]),a._v(" "),e("p",[a._v("A、abstract修饰的类，不可实例化，所以需要子类去继承，然后重写其中的抽象方法。但是final修饰类是不可继承的。两者属性相冲。不管是静态方法还是静态成员，都是类级别存在的，也就是说随着类的加载而加载，优先于对象的存在，而非静态成员和方法是对象级别的存在，所以在静态方法中调用非静态的成员或方法（此时还不存在对象），是不可能的，但是反过来是可以的：非静态中调用静态。于是也就有静态方法中不能使用this和super关键字。\nB、看清楚，人家说的是不建议有，不是不能有。\nC、抽象类中可以没有抽象方法，但是抽象方法必须在抽象类中或者接口中\nD、static不可以修饰非static的属性，因为类加载的时候，static属性比非static先初始化，那么一个存在的总不能访问一个没有存在的吧。")]),a._v(" "),e("p",[e("strong",[a._v("2.要导入java/awt/event下面的所有类，叙述正确的是？()")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("import java.awt.*和import java.awt.event.*都可以\n只能是import java.awt.*\n只能是import java.awt.event.*\nimport java.awt.*和import java.awt.event.*都不可以\n")])])]),e("p",[e("strong",[a._v("答案")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("只能是import java.awt.event.*\n")])])]),e("p",[e("strong",[a._v("解释")])]),a._v(" "),e("p",[a._v("导包只可以导到当前层，不可以再导入包里面的包中的类")]),a._v(" "),e("p",[e("strong",[a._v("3.在java语言中，如果你编写一个多线程序，可以使用的方法是（）")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("扩展类Thread\n实现Runnable接口\n扩展类 Runnable\n实现接口Thread\n")])])]),e("p",[e("strong",[a._v("答案")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("扩展类Thread\n实现Runnable接口\n")])])]),e("p",[e("strong",[a._v("解释")])]),a._v(" "),e("p",[e("a",{attrs:{href:"http://lib.csdn.net/base/javaee",target:"_blank",rel:"noopener noreferrer"}},[a._v("Java"),e("OutboundLink")],1),a._v("多线程实现方式主要有四种：继承Thread类、实现Runnable接口、实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService、Callable、Future实现有返回结果的多线程。")]),a._v(" "),e("p",[a._v("其中前两种方式线程执行完后都没有返回值，后两种是带返回值的。")])])}),[],!1,null,null,null);t.default=r.exports}}]);