(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{493:function(t,v,n){"use strict";n.r(v);var _=n(0),e=Object(_.a)({},(function(){var t=this,v=t.$createElement,n=t._self._c||v;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"第11次题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第11次题"}},[t._v("#")]),t._v(" 第11次题")]),t._v(" "),n("p",[n("strong",[t._v("1. 哪个类可用于处理 Unicode?")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("InputStreamReader\nBufferedReader\nWriter\nPipedInputStream\n")])])]),n("p",[n("strong",[t._v("答案")])]),t._v(" "),n("p",[t._v("InputStreamReader")]),t._v(" "),n("p",[n("strong",[t._v("解释")])]),t._v(" "),n("p",[t._v("InputStreamReader可以指定字符编码格式")]),t._v(" "),n("p",[n("strong",[t._v("2. Java数据库连接库JDBC用到哪种设计模式?")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("生成器\n桥接模式\n抽象工厂\n单例模式\n")])])]),n("p",[n("strong",[t._v("答案")])]),t._v(" "),n("p",[t._v("桥接模式")]),t._v(" "),n("p",[n("strong",[t._v("解释")])]),t._v(" "),n("p",[n("strong",[t._v("桥接模式：")])]),t._v(" "),n("p",[t._v("定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。")]),t._v(" "),n("p",[t._v("意图 ：将抽象与实现解耦。")]),t._v(" "),n("p",[n("strong",[t._v("桥接模式所涉及的角色")])]),t._v(" "),n("ol",[n("li",[n("strong",[t._v("Abstraction")]),t._v(" ：定义抽象接口，拥有一个Implementor类型的对象引用")]),t._v(" "),n("li",[n("strong",[t._v("RefinedAbstraction")]),t._v(" ：扩展Abstraction中的接口定义")]),t._v(" "),n("li",[n("strong",[t._v("Implementor")]),t._v(" ：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用")]),t._v(" "),n("li",[n("strong",[t._v("ConcreteImplementor")]),t._v(" ：实现Implementor接口，给出具体实现")])]),t._v(" "),n("p",[t._v("Jdk中的桥接模式：JDBC\nJDBC连接 "),n("a",{attrs:{href:"http://www.2cto.com/database/",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据库"),n("OutboundLink")],1),t._v(" 的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是JDBC提供了统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了")]),t._v(" "),n("p",[n("strong",[t._v("3.  在创建派生类对象，构造函数的执行顺序（）")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("基类构造函数，派生类对象成员构造函数，派生类本身的构造函数\n派生类本身的构造函数，基类构造函数，对象成员构造函数\n基类构造函数，派生类本身的构造函数，派生类对象成员构造函数\n对象成员构造函数，基类构造函数，派生类本身的构造函数\n")])])]),n("p",[n("strong",[t._v("答案")])]),t._v(" "),n("p",[t._v("基类构造函数，派生类对象成员构造函数，派生类本身的构造函数")]),t._v(" "),n("p",[n("strong",[t._v("解释")])]),t._v(" "),n("p",[t._v("父类的静态域-子类的静态域 父类的非静态域-父类的构造函数 子类的非静态域-子类的构造函数 规律就是 父类先于子类 静态的先于非静态的")]),t._v(" "),n("p",[t._v("其中静态域包含静态代码块与静态方法，这个谁在前面，则先执行谁。")]),t._v(" "),n("p",[t._v("非静态域同理")]),t._v(" "),n("p",[n("strong",[t._v("4. 类之间存在以下几种常见的关系：")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("“USES-A”关系\n“HAS-A”关系\n“IS-A”关系\n“INHERIT-A”关系\n")])])]),n("p",[n("strong",[t._v("答案")])]),t._v(" "),n("p",[t._v("“USES-A”关系\n“HAS-A”关系\n“IS-A”关系")]),t._v(" "),n("p",[n("strong",[t._v("解释")])]),t._v(" "),n("p",[t._v("**USES-A：**依赖关系，A类会用到B类，这种关系具有偶然性，临时性。但B类的变化会影响A类。这种在代码中的体现为：A类方法中的参数包含了B类。")]),t._v(" "),n("p",[t._v("**关联关系：**A类会用到B类，这是一种强依赖关系，是长期的并非偶然。在代码中的表现为：A类的成员变量中含有B类。")]),t._v(" "),n("p",[n("strong",[t._v("HAS-A："),n("strong",[t._v("聚合关系，拥有关系，是")]),t._v("关联关系")]),t._v("的一种特例，是整体和部分的关系。比如鸟群和鸟的关系是聚合关系，鸟群中每个部分都是鸟。")]),t._v(" "),n("p",[t._v("**IS-A：**表示继承。父类与子类，这个就不解释了。")]),t._v(" "),n("p",[t._v("要注意：还有一种关系："),n("strong",[t._v("组合关系")]),t._v("也是关联关系的一种特例，它体现一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分的关系，但这种整体和部分是不可分割的。")]),t._v(" "),n("ol",{attrs:{start:"5"}},[n("li")]),t._v(" "),n("p",[n("strong",[t._v("答案")])]),t._v(" "),n("p",[n("strong",[t._v("解释")])])])}),[],!1,null,null,null);v.default=e.exports}}]);