# 模拟面试题1

- 请问object的hash该怎么设计

    > hash方法 - (NSUInteger)hash返回一个整数,这个数代表的就是当前对象的哈希值 有一个很重要的规范 : 如果两个对象相等,他们的hash值必须相等, 如果某个类自定义了isEqual方法,并且这个类的实例有可能会被加入到集合中,一点要确保hash方法被重新定义 和数组把元素存储在一系列连续的地址中不同，哈希算法使得 NSSet 和 NSDictionary 能够非常快速地(O(1)) 进行元素查找,哈希表会在内存中分配n个位置，然后使用一个函数来计算出位置范围之内的某个具***置. 在数组和hash表中要判断一个元素是不是存在的算法和效率是不一样的，数组需要对数组中每个元素的位置都进行检查,hash有一个更快速的查找方式. 一个好的 hash函数在不需要太多计算量的情况下，可以使得生成的位置分布接近于均匀分布,当两个不同的对象计算出相同的散列值时，我们称其为发生了 哈希碰撞 。当出现碰撞时，哈希表会从碰撞产生的位置开始向后寻找，把新的元素放在第一个可供放置的位置,随着哈希表变得越来越致密，发生碰撞的可能性也会随之增加，导致查找可用位置花费的时间也会增加（这也是为什么我们希望哈希函数的结果分布更接近于均匀分布）

- 请你介绍一下，数据库的三个范式？

    > **第一范式（1NF）**强调的是列的原子性，即列不能够再分成其他几列。
    >
    > 
    >
    > **第二范式（2NF）**首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。在1NF基础上，任何非主属性不依赖于其它非主属性[在2NF基础上消除传递依赖]。
    >
    > 
    >
    > **第三范式（3NF）**第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。 首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。

- 写代码

    > ## 数组中的逆序对
    >
    > 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
    >
    > 输入描述
    >
    > ```
    > 题目保证输入的数组中没有的相同的数字数据范围：	对于%50的数据,size<=10^4	对于%75的数据,size<=10^5	对于%100的数据,size<=2*10^5
    > ```
    >
    > 示例1
    >
    > ## 输入
    >
    > ```
    > 1,2,3,4,5,6,7,0
    > ```
    >
    > ## 输出
    >
    > ```
    > 7
    > ```